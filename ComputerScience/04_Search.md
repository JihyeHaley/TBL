

# 4️⃣ Week 4 (Array)

##### Based on C++ using sandbox provided by CS50

* Search Algorithm

  `O(n^2)` **(**`Ω(n^2)`**)**: **Selection Search**, **(Bubble Search)**

  `O(n log n)`: **Merge Sort**

  `O(n)` : **Linear Search**

  `O(log n)` : **Binary Search**

  `O(1)`



### 🧼  `Ω(n^2)` 버블 정렬

<hr>

정렬되지 않은 리스트를 탐색하는 것 보다 정렬한 뒤 탐색하는 것이 더 효율적입니다.

정렬 알고리즘 중 하나는 **버블 정렬**입니다.

버블 정렬은 **두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬**하는 방법을 말합니다.

버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중합니다.

이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있습니다.



아래와 같은 8개의 숫자가 임의의 순서로 나열되어 있습니다.

이 숫자들을 **오름차순**으로 정렬하기 위해 바로 옆의 있는 숫자들과 비교하는 방법을 사용해 보겠습니다.

 

6 3 8 5 2 7 4 1



먼저 가장 앞의 6과 3을 비교해서 순서를 바꿉니다.

 

교환 전: **6 3** 8 5 2 7 4 1

교환 후: **3 6** 8 5 2 7 4 1



다음 쌍인 6과 8을 비교해보면 교환할 필요가 없으므로 그대로 둡니다.

바로 다음에 있는 쌍인 8과 5를 비교해서 순서를 바꿉니다.

 

교환 전: 3 6 **8 5** 2 7 4 1

교환 후: 3 6 **5 8** 2 7 4 1



이런 식으로 숫자 끝까지 진행하면 아래와 같이 정렬이 됩니다.

 

3 6 5 2 7 4 1 8



하지만 아직 오름차순으로 정렬이 되지 않았기 때문에, 다시 처음부터 동일한 작업을 반복합니다.

 

**3 6** 5 2 7 4 1 8

3 **6 5** 2 7 4 1 8 (교환)

3 5 **6 2** 7 4 1 8 (교환)

3 5 2 **6 7** 4 1 8 

3 5 2 6 **7 4** 1 8 (교환)

3 5 2 6 4 **7 1** 8 (교환)

3 5 2 6 4 1 **7 8**



조금 더 잘 정렬이 되었습니다. 이 과정을 끝까지 반복하면 최종적으로 아래와 같이 오름차순 정렬이 될 것입니다.



1 2 4 3 5 6 7 8



이러한 정렬 방식을 **‘버블 정렬’**이라고 합니다.

마치 거품이(비교 및 교환이) 터지면서 위로 올라오는 (배열의 옆으로 이동하는) 방식이기 때문입니다

* ![image](https://user-images.githubusercontent.com/58539681/89391953-d3896900-d743-11ea-94cc-6fba327ef15f.png)



### 🍭  O(n^2) 선택 정렬

<hr>

보통 배열이 정렬되어 있으면 정렬되지 않은 배열보다 더 쉽게 탐색할 수 있습니다.

정렬을 위한 알고리즘 중 **선택정렬**을 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬입니다.

**선택** **정렬**은 **교환 횟수를** **최소화**하는 반면 각 자료를 비교하는 횟수는 증가합니다.



다음과 같은 정렬되지 않은 숫자들을 오름차순 정렬해보도록 하겠습니다.

 

6 3 8 5 2 7 4 1



먼저 아래 숫자들 중에서 가장 작은 값을 찾습니다.

 

6 3 8 5 2 7 4 **1**

 

가장 작은 값인 1은 가장 앞에 있어야 하므로 현재 리스트의 첫 번째 값인 6과 교환합니다.

 

**1** 3 8 5 2 7 4 **6**



그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾습니다.

 

1 3 8 5 **2** 7 4 6

 

가장 작은 값인 2는 정렬되지 않는 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환합니다.

 

1 **2** 8 5 **3** 7 4 6



이 과정을 더 이상 교환이 일어나지 않을때까지 반복하면, 아래와 같이 오름차순 정렬이 완료됩니다.

 

1 2 3 4 5 6 7 8



이러한 정렬 방법을 **‘선택 정렬’** 이라고 합니다. 의사 코드로 아래와 같이 표현할 수 있습니다.

* ![image](https://user-images.githubusercontent.com/58539681/89402233-7e545400-d751-11ea-9e35-897953a1ebef.png)